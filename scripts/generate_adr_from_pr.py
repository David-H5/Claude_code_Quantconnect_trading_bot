#!/usr/bin/env python3
"""
Auto-generate Architecture Decision Records from git commits/PRs.

Based on: https://adr.github.io/
Inspired by: https://medium.com/@iraj.hedayati/from-stale-docs-to-living-architecture-automating-adrs-with-github-llm

Usage:
    python scripts/generate_adr_from_pr.py [--from-commit HASH] [--dry-run]
    python scripts/generate_adr_from_pr.py --create "Title" --context "..." --decision "..."

Creates ADRs in docs/adr/ following the standard format.
"""

import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any


ADR_DIR = Path("docs/adr")

ADR_TEMPLATE = """# ADR-{number}: {title}

**Date:** {date}
**Status:** {status}
**Deciders:** {deciders}

## Context

{context}

## Decision

{decision}

## Consequences

### Positive

{positive_consequences}

### Negative

{negative_consequences}

### Neutral

{neutral_consequences}

## Related

- Source: {source}
- Files Changed: {files_changed}
{related_adrs}

---

*Generated by `scripts/generate_adr_from_pr.py`*
"""


def get_next_adr_number() -> int:
    """
    Get the next available ADR number.

    Returns:
        Next ADR number to use.
    """
    ADR_DIR.mkdir(parents=True, exist_ok=True)

    existing = list(ADR_DIR.glob("ADR-*.md"))
    if not existing:
        return 1

    numbers = []
    for f in existing:
        match = re.match(r"ADR-(\d+)", f.stem)
        if match:
            numbers.append(int(match.group(1)))

    return max(numbers) + 1 if numbers else 1


def sanitize_filename(title: str) -> str:
    """
    Convert title to valid filename component.

    Args:
        title: ADR title.

    Returns:
        Sanitized string for filename.
    """
    # Remove special characters, convert spaces to underscores
    clean = re.sub(r"[^\w\s-]", "", title.lower())
    clean = re.sub(r"[-\s]+", "_", clean)
    return clean[:40]  # Limit length


def get_commit_info(commit_hash: str = "HEAD") -> dict[str, Any]:
    """
    Get information about a git commit.

    Args:
        commit_hash: Git commit hash or reference.

    Returns:
        Dict with commit info: subject, body, author, files_changed.
    """
    try:
        # Get commit message
        result = subprocess.run(
            ["git", "log", "-1", "--format=%s%n%n%b", commit_hash],
            capture_output=True,
            text=True,
            check=True,
        )
        lines = result.stdout.strip().split("\n")
        subject = lines[0] if lines else "Untitled"
        body = "\n".join(lines[2:]).strip() if len(lines) > 2 else ""

        # Get author
        result = subprocess.run(
            ["git", "log", "-1", "--format=%an <%ae>", commit_hash],
            capture_output=True,
            text=True,
            check=True,
        )
        author = result.stdout.strip()

        # Get files changed
        result = subprocess.run(
            ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit_hash],
            capture_output=True,
            text=True,
            check=True,
        )
        files = result.stdout.strip().split("\n")
        files = [f for f in files if f]  # Remove empty

        # Get diff stats
        result = subprocess.run(
            ["git", "diff", "--stat", f"{commit_hash}~1..{commit_hash}"],
            capture_output=True,
            text=True,
        )
        diff_stats = result.stdout.strip()

        return {
            "subject": subject,
            "body": body,
            "author": author,
            "files": files,
            "files_count": len(files),
            "diff_stats": diff_stats,
            "hash": commit_hash,
        }
    except subprocess.CalledProcessError as e:
        return {
            "subject": "Unknown",
            "body": "",
            "author": "Unknown",
            "files": [],
            "files_count": 0,
            "diff_stats": "",
            "hash": commit_hash,
            "error": str(e),
        }


def is_architectural_commit(commit_info: dict[str, Any]) -> bool:
    """
    Determine if a commit warrants an ADR.

    Args:
        commit_info: Commit information dict.

    Returns:
        True if commit should have an ADR.
    """
    subject = commit_info["subject"].lower()
    body = commit_info.get("body", "").lower()
    files = commit_info.get("files", [])

    # Architectural keywords in subject
    arch_keywords = [
        "architect",
        "refactor",
        "migrate",
        "redesign",
        "restructure",
        "pattern",
        "framework",
        "infrastructure",
        "adr",
        "decision",
    ]
    if any(kw in subject for kw in arch_keywords):
        return True

    # Breaking changes
    if "!" in subject or "breaking" in subject or "breaking" in body:
        return True

    # Large changes (10+ files)
    if len(files) >= 10:
        return True

    # Creates new module/package
    new_module_patterns = [
        r"^[a-z]+/__init__\.py$",
        r"^[a-z]+/[a-z]+/__init__\.py$",
    ]
    for f in files:
        for pattern in new_module_patterns:
            if re.match(pattern, f):
                return True

    return False


def extract_adr_content(commit_info: dict[str, Any]) -> dict[str, str]:
    """
    Extract ADR content from commit information.

    Args:
        commit_info: Commit information dict.

    Returns:
        Dict with title, context, decision, consequences.
    """
    subject = commit_info["subject"]
    body = commit_info.get("body", "")
    files = commit_info.get("files", [])

    # Parse conventional commit format
    # Format: type(scope): description
    match = re.match(r"(\w+)(?:\(([^)]+)\))?\!?:\s*(.+)", subject)
    if match:
        commit_type = match.group(1)
        scope = match.group(2)
        description = match.group(3)
        if scope:
            title = f"{commit_type.title()}({scope}): {description}"
        else:
            title = f"{commit_type.title()}: {description}"
    else:
        title = subject
        description = subject

    # Categorize files by module
    modules = set()
    for f in files:
        parts = Path(f).parts
        if parts:
            modules.add(parts[0])

    # Build context
    context_parts = [
        f"This change affects the following modules: {', '.join(sorted(modules))}.",
    ]
    if body:
        context_parts.append("")
        context_parts.append("From commit message:")
        context_parts.append(body)

    context = "\n".join(context_parts)

    # Build decision
    decision = f"Implemented {description if match else subject}."
    if files:
        decision += "\n\nKey files changed:\n"
        for f in files[:10]:
            decision += f"- `{f}`\n"
        if len(files) > 10:
            decision += f"- ... and {len(files) - 10} more files\n"

    # Default consequences
    positive = "- Improves code organization\n- Better maintainability"
    negative = "- Requires team to learn new structure\n- Migration effort required"
    neutral = "- Existing functionality preserved"

    return {
        "title": title,
        "context": context,
        "decision": decision,
        "positive_consequences": positive,
        "negative_consequences": negative,
        "neutral_consequences": neutral,
    }


def create_adr(
    title: str,
    context: str,
    decision: str,
    positive: str = "- To be determined",
    negative: str = "- To be determined",
    neutral: str = "- No neutral consequences identified",
    source: str = "Manual creation",
    files_changed: int = 0,
    deciders: str = "Development Team",
    status: str = "Proposed",
    related_adrs: list[str] | None = None,
) -> Path:
    """
    Create a new ADR file.

    Args:
        title: ADR title.
        context: Context section content.
        decision: Decision section content.
        positive: Positive consequences.
        negative: Negative consequences.
        neutral: Neutral consequences.
        source: Source of the decision (commit, PR, etc.).
        files_changed: Number of files changed.
        deciders: Who made the decision.
        status: ADR status (Proposed, Accepted, Deprecated, Superseded).
        related_adrs: List of related ADR references.

    Returns:
        Path to created ADR file.
    """
    ADR_DIR.mkdir(parents=True, exist_ok=True)

    number = get_next_adr_number()
    filename = f"ADR-{number:04d}_{sanitize_filename(title)}.md"

    related_str = ""
    if related_adrs:
        related_str = "\n".join(f"- Related: {adr}" for adr in related_adrs)

    content = ADR_TEMPLATE.format(
        number=f"{number:04d}",
        title=title,
        date=datetime.now().strftime("%Y-%m-%d"),
        status=status,
        deciders=deciders,
        context=context,
        decision=decision,
        positive_consequences=positive,
        negative_consequences=negative,
        neutral_consequences=neutral,
        source=source,
        files_changed=files_changed,
        related_adrs=related_str,
    )

    adr_path = ADR_DIR / filename
    adr_path.write_text(content)

    return adr_path


def main() -> int:
    """
    Main entry point for ADR generation.

    Returns:
        Exit code (0 for success).
    """
    dry_run = "--dry-run" in sys.argv

    # Manual creation mode
    if "--create" in sys.argv:
        idx = sys.argv.index("--create")
        if idx + 1 >= len(sys.argv):
            print("Error: --create requires a title")
            return 1

        title = sys.argv[idx + 1]
        context = "Context to be filled in."
        decision = "Decision to be documented."

        # Optional arguments
        if "--context" in sys.argv:
            ctx_idx = sys.argv.index("--context")
            if ctx_idx + 1 < len(sys.argv):
                context = sys.argv[ctx_idx + 1]

        if "--decision" in sys.argv:
            dec_idx = sys.argv.index("--decision")
            if dec_idx + 1 < len(sys.argv):
                decision = sys.argv[dec_idx + 1]

        if dry_run:
            print(f"Would create ADR: {title}")
            print(f"Context: {context[:100]}...")
            print(f"Decision: {decision[:100]}...")
            return 0

        adr_path = create_adr(
            title=title,
            context=context,
            decision=decision,
            source="Manual creation",
        )
        print(f"Created: {adr_path}")
        return 0

    # From commit mode
    commit_hash = "HEAD"
    if "--from-commit" in sys.argv:
        idx = sys.argv.index("--from-commit")
        if idx + 1 < len(sys.argv):
            commit_hash = sys.argv[idx + 1]

    # Get commit info
    commit_info = get_commit_info(commit_hash)

    if "error" in commit_info:
        print(f"Error reading commit: {commit_info['error']}")
        return 1

    print(f"Analyzing commit: {commit_hash}")
    print(f"Subject: {commit_info['subject']}")
    print(f"Files changed: {commit_info['files_count']}")

    # Check if architectural
    if not is_architectural_commit(commit_info):
        print("\nThis commit does not appear to be architectural.")
        print("Use --create to manually create an ADR, or add 'ADR:' to commit message.")
        return 0

    print("\nThis appears to be an architectural change.")

    # Extract content
    content = extract_adr_content(commit_info)

    if dry_run:
        print("\n--- DRY RUN ---")
        print(f"Would create ADR: {content['title']}")
        print(f"\nContext:\n{content['context'][:200]}...")
        print(f"\nDecision:\n{content['decision'][:200]}...")
        return 0

    # Create ADR
    adr_path = create_adr(
        title=content["title"],
        context=content["context"],
        decision=content["decision"],
        positive=content["positive_consequences"],
        negative=content["negative_consequences"],
        neutral=content["neutral_consequences"],
        source=f"Commit {commit_hash[:8]}",
        files_changed=commit_info["files_count"],
        deciders=commit_info["author"],
    )

    print(f"\nCreated: {adr_path}")
    print("\nPlease review and update the ADR with:")
    print("- Specific context details")
    print("- Concrete consequences")
    print("- Related ADR references")

    return 0


if __name__ == "__main__":
    sys.exit(main())
