"""
Base Monitoring Infrastructure

Provides abstract interfaces and common types for all monitoring components.
Enables consistent monitoring across system resources, services, and trading.

Refactored: Phase 4 - Unified Monitoring & Alerting Infrastructure
"""

from abc import ABC, abstractmethod
from collections.abc import Callable
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any


# ==============================================================================
# Enums and Constants
# ==============================================================================


class HealthStatus(Enum):
    """Health status levels for monitored components."""

    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"
    UNKNOWN = "unknown"


class MonitorSeverity(Enum):
    """Severity levels for monitor alerts."""

    DEBUG = "debug"
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

    @property
    def level(self) -> int:
        """Get numeric level for comparison."""
        levels = {
            "debug": 10,
            "info": 20,
            "warning": 30,
            "error": 40,
            "critical": 50,
        }
        return levels.get(self.value, 0)

    def __ge__(self, other: "MonitorSeverity") -> bool:
        return self.level >= other.level

    def __gt__(self, other: "MonitorSeverity") -> bool:
        return self.level > other.level

    def __le__(self, other: "MonitorSeverity") -> bool:
        return self.level <= other.level

    def __lt__(self, other: "MonitorSeverity") -> bool:
        return self.level < other.level


class MonitorCategory(Enum):
    """Categories of monitoring."""

    SYSTEM = "system"
    RESOURCE = "resource"
    STORAGE = "storage"
    NETWORK = "network"
    SERVICE = "service"
    TRADING = "trading"
    PERFORMANCE = "performance"
    ANOMALY = "anomaly"


# ==============================================================================
# Data Classes
# ==============================================================================


@dataclass
class MonitorCheck:
    """Configuration for a monitoring check."""

    name: str
    check_fn: Callable[[], bool]
    category: MonitorCategory = MonitorCategory.SYSTEM
    interval_seconds: int = 60
    timeout_seconds: int = 10
    failure_threshold: int = 3
    recovery_threshold: int = 2
    enabled: bool = True


@dataclass
class MonitorState:
    """Current state of a monitored component."""

    name: str
    category: MonitorCategory = MonitorCategory.SYSTEM
    status: HealthStatus = HealthStatus.UNKNOWN
    last_check: datetime | None = None
    last_success: datetime | None = None
    last_failure: datetime | None = None
    consecutive_failures: int = 0
    consecutive_successes: int = 0
    total_checks: int = 0
    total_failures: int = 0
    error_message: str = ""
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "name": self.name,
            "category": self.category.value,
            "status": self.status.value,
            "last_check": self.last_check.isoformat() if self.last_check else None,
            "last_success": self.last_success.isoformat() if self.last_success else None,
            "last_failure": self.last_failure.isoformat() if self.last_failure else None,
            "consecutive_failures": self.consecutive_failures,
            "consecutive_successes": self.consecutive_successes,
            "total_checks": self.total_checks,
            "total_failures": self.total_failures,
            "error_message": self.error_message,
            "metadata": self.metadata,
        }


@dataclass
class MonitorAlert:
    """Alert generated by a monitor."""

    monitor_name: str
    severity: MonitorSeverity
    category: MonitorCategory
    message: str
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    metric_name: str | None = None
    current_value: float | None = None
    threshold_value: float | None = None
    data: dict[str, Any] = field(default_factory=dict)
    alert_id: str = ""

    def __post_init__(self) -> None:
        """Generate alert ID if not provided."""
        if not self.alert_id:
            self.alert_id = f"{self.timestamp.timestamp():.0f}-{self.monitor_name}-{id(self)}"

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "alert_id": self.alert_id,
            "monitor_name": self.monitor_name,
            "severity": self.severity.value,
            "category": self.category.value,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "metric_name": self.metric_name,
            "current_value": self.current_value,
            "threshold_value": self.threshold_value,
            "data": self.data,
        }


@dataclass
class MonitorMetrics:
    """Aggregated metrics from a monitor."""

    monitor_name: str
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    values: dict[str, float] = field(default_factory=dict)
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "monitor_name": self.monitor_name,
            "timestamp": self.timestamp.isoformat(),
            "values": self.values,
            "metadata": self.metadata,
        }


# ==============================================================================
# Abstract Base Classes
# ==============================================================================


class AbstractMonitor(ABC):
    """
    Abstract base class for all monitors.

    Monitors observe system state and generate alerts when thresholds are exceeded.
    """

    @property
    @abstractmethod
    def name(self) -> str:
        """Get monitor name."""
        ...

    @property
    @abstractmethod
    def category(self) -> MonitorCategory:
        """Get monitor category."""
        ...

    @abstractmethod
    def check(self) -> MonitorState:
        """
        Perform a health check.

        Returns:
            MonitorState with current status
        """
        ...

    @abstractmethod
    def get_metrics(self) -> MonitorMetrics:
        """
        Get current metrics.

        Returns:
            MonitorMetrics with current values
        """
        ...

    @abstractmethod
    def is_healthy(self) -> bool:
        """
        Check if the monitored component is healthy.

        Returns:
            True if healthy, False otherwise
        """
        ...

    def get_alerts(self) -> list[MonitorAlert]:
        """
        Get any pending alerts.

        Returns:
            List of alerts (empty if none)
        """
        return []

    def clear_alerts(self) -> None:
        """Clear pending alerts."""
        pass


class AbstractAlertHandler(ABC):
    """
    Abstract base class for alert handlers (channels).

    Alert handlers receive alerts and deliver them via various channels
    (email, Slack, webhook, etc.).
    """

    @property
    @abstractmethod
    def name(self) -> str:
        """Get handler name."""
        ...

    @property
    @abstractmethod
    def enabled(self) -> bool:
        """Check if handler is enabled."""
        ...

    @abstractmethod
    def send(self, alert: MonitorAlert) -> bool:
        """
        Send an alert via this handler.

        Args:
            alert: The alert to send

        Returns:
            True if sent successfully, False otherwise
        """
        ...

    def can_handle(self, alert: MonitorAlert) -> bool:
        """
        Check if this handler can handle the alert.

        Default: handle all alerts if enabled.

        Args:
            alert: The alert to check

        Returns:
            True if handler can process this alert
        """
        return self.enabled

    def format_alert(self, alert: MonitorAlert) -> str:
        """
        Format alert for display.

        Args:
            alert: The alert to format

        Returns:
            Formatted string
        """
        return f"[{alert.severity.value.upper()}] {alert.monitor_name}: {alert.message}"


# ==============================================================================
# Composite Monitor
# ==============================================================================


class CompositeMonitor(AbstractMonitor):
    """
    Monitor that aggregates multiple child monitors.

    Useful for creating hierarchical monitoring structures.
    """

    def __init__(
        self,
        name: str,
        category: MonitorCategory = MonitorCategory.SYSTEM,
        monitors: list[AbstractMonitor] | None = None,
    ):
        """
        Initialize composite monitor.

        Args:
            name: Monitor name
            category: Monitor category
            monitors: Initial list of child monitors
        """
        self._name = name
        self._category = category
        self._monitors: list[AbstractMonitor] = monitors or []
        self._last_state: MonitorState | None = None

    @property
    def name(self) -> str:
        return self._name

    @property
    def category(self) -> MonitorCategory:
        return self._category

    def add_monitor(self, monitor: AbstractMonitor) -> None:
        """Add a child monitor."""
        self._monitors.append(monitor)

    def remove_monitor(self, name: str) -> bool:
        """Remove a child monitor by name."""
        for i, m in enumerate(self._monitors):
            if m.name == name:
                self._monitors.pop(i)
                return True
        return False

    def check(self) -> MonitorState:
        """Check all child monitors and aggregate status."""
        now = datetime.now(timezone.utc)

        if not self._monitors:
            self._last_state = MonitorState(
                name=self._name,
                category=self._category,
                status=HealthStatus.UNKNOWN,
                last_check=now,
            )
            return self._last_state

        child_states = [m.check() for m in self._monitors]

        # Aggregate status (worst status wins)
        statuses = [s.status for s in child_states]
        if HealthStatus.UNHEALTHY in statuses:
            overall_status = HealthStatus.UNHEALTHY
        elif HealthStatus.DEGRADED in statuses:
            overall_status = HealthStatus.DEGRADED
        elif all(s == HealthStatus.HEALTHY for s in statuses):
            overall_status = HealthStatus.HEALTHY
        else:
            overall_status = HealthStatus.UNKNOWN

        self._last_state = MonitorState(
            name=self._name,
            category=self._category,
            status=overall_status,
            last_check=now,
            metadata={"child_states": [s.to_dict() for s in child_states]},
        )

        return self._last_state

    def get_metrics(self) -> MonitorMetrics:
        """Aggregate metrics from all child monitors."""
        all_values: dict[str, float] = {}

        for monitor in self._monitors:
            metrics = monitor.get_metrics()
            for key, value in metrics.values.items():
                all_values[f"{monitor.name}.{key}"] = value

        return MonitorMetrics(
            monitor_name=self._name,
            values=all_values,
        )

    def is_healthy(self) -> bool:
        """Check if all child monitors are healthy."""
        return all(m.is_healthy() for m in self._monitors)

    def get_alerts(self) -> list[MonitorAlert]:
        """Get alerts from all child monitors."""
        alerts = []
        for monitor in self._monitors:
            alerts.extend(monitor.get_alerts())
        return alerts


# ==============================================================================
# Factory Functions
# ==============================================================================


def create_monitor_state(
    name: str,
    category: MonitorCategory = MonitorCategory.SYSTEM,
    status: HealthStatus = HealthStatus.UNKNOWN,
    **kwargs: Any,
) -> MonitorState:
    """
    Create a MonitorState with common defaults.

    Args:
        name: Monitor name
        category: Monitor category
        status: Initial status
        **kwargs: Additional fields

    Returns:
        MonitorState instance
    """
    return MonitorState(
        name=name,
        category=category,
        status=status,
        last_check=datetime.now(timezone.utc),
        **kwargs,
    )


def create_alert(
    monitor_name: str,
    severity: MonitorSeverity,
    category: MonitorCategory,
    message: str,
    **kwargs: Any,
) -> MonitorAlert:
    """
    Create a MonitorAlert with common defaults.

    Args:
        monitor_name: Source monitor name
        severity: Alert severity
        category: Alert category
        message: Alert message
        **kwargs: Additional fields

    Returns:
        MonitorAlert instance
    """
    return MonitorAlert(
        monitor_name=monitor_name,
        severity=severity,
        category=category,
        message=message,
        **kwargs,
    )


def create_composite_monitor(
    name: str,
    category: MonitorCategory = MonitorCategory.SYSTEM,
    monitors: list[AbstractMonitor] | None = None,
) -> CompositeMonitor:
    """
    Create a CompositeMonitor that aggregates multiple child monitors.

    Args:
        name: Monitor name
        category: Monitor category
        monitors: Initial list of child monitors

    Returns:
        CompositeMonitor instance
    """
    return CompositeMonitor(
        name=name,
        category=category,
        monitors=monitors,
    )
